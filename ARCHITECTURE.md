# Ambient Life (NWN2) — Архитектура и ключевые механизмы (документ проектирования)

## 1) Назначение системы

Ambient Life — это высокопроизводительная система “жизнедеятельности” NPC, ориентированная на:

- нулевую активность при отсутствии игроков в области;
- минимальную активность при наличии игроков (один таймер на область);
- управление поведением NPC через событийный протокол, без heartbeats и без таймеров на NPC.

Система строится на стандартной модели NWScript “событие → запуск привязанного скрипта” (OnEnter/OnExit/OnUserDefined и т. п.).

## 2) Жёсткие требования производительности (инварианты)

- Нет heartbeat на NPC.
- NPC не должны иметь собственных периодических тиков и не должны выполнять фоновые циклы.
- Один тик на область, и только когда PC > 0.
  - Реализуется через DelayCommand на области.
- При неизменном слоте суток — нулевая работа, кроме:
  - вычисления текущего слота,
  - сравнения со старым,
  - планирования следующего тика.
- Никаких runtime-поисков по тегам/строкам (GetObjectByTag, GetNearestObjectByTag и т. п.) для управления жизнедеятельностью.
- Все NPC, которыми управляет система, должны быть в плотном реестре.

## 3) Модель компонентов

### 3.1 Area Controller (контроллер области)

Ответственность:

- отслеживать присутствие игроков (PC count);
- управлять жизненным циклом области: activate / tick / deactivate;
- вычислять “слот суток” (0–5);
- рассылать события NPC:
  - EVT_RESYNC при активации,
  - EVT_SLOT_x только при смене слота.

Техническая основа:

- OnEnter/OnExit области и единый таймер через DelayCommand.

### 3.2 NPC Agent (агент NPC)

Ответственность:

- принимать OnUserDefined события;
- поддерживать свой “последний применённый слот”;
- выполнять действия, соответствующие слоту (в следующих этапах: move/anim/schedule);
- корректно обрабатываться при hide/freeze/unfreeze.

Механизм коммуникации:

- EventUserDefined + SignalEvent → запуск OnUserDefined скрипта цели.

### 3.3 NPC Registry (реестр NPC на области)

Ответственность:

- хранить управляемых NPC в виде плотного массива 0..N-1;
- обеспечивать быстрый O(1) add/remove (через swap-remove);
- не допускать дыр и необходимости обходить мир.

## 4) Время и “слоты суток”

### 4.1 Слот суток 0–5

Определение:

- берём текущий игровой час GetTimeHour();
- делим сутки на 6 отрезков по 4 часа:
  - slot = floor(hour / 4) → 0..5.

Примечание: “игровой час” — это модульное игровое время; соотношение игрового часа и реального времени зависит от настроек модуля.

### 4.2 Период тика области

Фиксируем период (например) 45 секунд реального времени для баланса нагрузки и отзывчивости. Реализация — DelayCommand(секунды, действие).

## 5) Протокол событий (Event IDs)

### 5.1 UserDefined события

Система использует кастомные номера user-defined событий:

- EVT_SLOT_0..5 = BASE + slot
- EVT_RESYNC = отдельный ID (например, BASE + 6)

Рекомендация/ограничение: не использовать диапазоны, занятые стандартными событиями BioWare (1000–1011, 1510, 1511).

### 5.2 Отправка и приём событий

- Создание события: EventUserDefined(n)
- Доставка: SignalEvent(target, event)
- Приём в OnUserDefined: GetUserDefinedEventNumber()

Важная семантика: SignalEvent заставляет объект обработать событие после завершения текущего скрипта, не “в середине” исполнения.

## 6) Данные и хранение состояния (locals)

### 6.1 Почему locals

Locals (SetLocalInt / GetLocalInt) — дешёвый способ хранить небольшое состояние на объекте/области без внешних структур.

### 6.2 Минимальные locals области (рекомендуемый набор)

(Названия краткие, чтобы уменьшить накладные расходы на строки и поддерживать компактность.)

| Local | Тип | Смысл |
| --- | --- | --- |
| p | int | кол-во PC в области |
| t | int | токен “поколения” тика (инвалидация старых отложенных вызовов) |
| s | int | текущий слот 0..5 |
| n | int | размер реестра NPC |
| n0..n99 | object | плотный массив NPC |

### 6.3 Минимальные locals NPC

| Local | Тип | Смысл |
| --- | --- | --- |
| l | int | последний применённый слот (например, старт = -1) |

## 7) Основные потоки (control flow)

### 7.1 Активация области (PC count 0 → 1)

Триггер: OnEnter области, вошёл PC. Получение входящего объекта — через GetEnteringObject() и использовать только в OnEnter.

Действия:

1. p++, если стало p == 1:
   - Инкремент t (новое поколение тика).
   - Вычислить слот s.
   - Для всех NPC из реестра:
     - unhide/unfreeze (см. 7.4),
     - отправить EVT_RESYNC.
   - Запланировать AreaTick через DelayCommand.

### 7.2 Деактивация области (PC count 1 → 0)

Триггер: OnExit области, вышел PC. Для OnExit/OnClientLeave используется GetExitingObject().

Действия:

1. p-- до минимума 0.
2. Если стало p == 0:
   - инкремент t (убить все старые тики по токену),
   - для всех NPC из реестра: hide/freeze (см. 7.4).

### 7.3 Тик области (AreaTick)

Цель: обновлять слот суток и при необходимости рассылать EVT_SLOT_x.

Алгоритм:

1. Если p <= 0 — завершить, следующий тик не планировать.
2. Если токен вызова ≠ t — это старый тик, завершить.
3. Вычислить slotNew из GetTimeHour().
4. Если slotNew == s:
   - не обходить NPC,
   - просто запланировать следующий тик (DelayCommand).
5. Если slotNew != s:
   - s = slotNew,
   - для всех NPC из реестра отправить EVT_SLOT_slotNew.

### 7.4 Hide/Freeze и Unhide/Unfreeze (механизм “паузы NPC”)

Базовый механизм для деактивации:

- SetScriptHidden(creature, TRUE, bDisableAI) скрывает существо: оно не рендерится, не участвует в коллизии и не выбирается клиентом; опционально можно отключать AI, пока скрыто.

Для активации:

- SetScriptHidden(creature, FALSE, …) возвращает видимость/коллизию/выбор.

Дополнение (опционально, для гарантированного “остановить немедленно”):

- очистка очереди действий ClearAllActions() (если в следующих этапах NPC активно двигаются/исполняют действия).

## 8) Реестр NPC: плотность, валидность, обслуживание

### 8.1 Плотный массив

Храним NPC как n0..n99 и n (размер).

Обход реестра делается только:

- при активации/деактивации,
- при смене слота,
- при обслуживании валидности.

### 8.2 Удаление “битых” ссылок без дыр

При обходе:

- если объект в слоте невалиден — удалить через swap-remove:
  - заменить текущий элемент последним (n-1),
  - уменьшить n,
  - продолжить с тем же индексом (чтобы не пропустить “подменённый” элемент).

Это обеспечивает:

- отсутствие дыр,
- линейный обход только при редких событиях (slot change / activate / deactivate).

## 9) Обработка на стороне NPC (OnUserDefined)

Триггер: пришло user-defined событие; номер читается GetUserDefinedEventNumber() и должен вызываться только в OnUserDefined.

Логика:

- Если EVT_RESYNC:
  - взять текущий слот области (s) и применить как “целевой”.
- Если EVT_SLOT_x:
  - извлечь x и применить как “целевой”.
- Если целевой слот == l (last applied) — выход (идемпотентность).
- Иначе: l = slot и выполнить сценарий слота (в следующих этапах: маршрут, анимации, точки интереса).

## 10) Механизм “токена тика” (защита от устаревших DelayCommand)

Проблема: DelayCommand ставит отложенные вызовы; при деактивации области может “прилететь” старый тик.

Решение:

- хранить t (int) на области;
- при каждом запуске тика передавать “ожидаемый token”;
- тик выполняется только если token совпал с текущим t.

Это даёт:

- отсутствие необходимости отменять DelayCommand (в NWScript нет прямого cancel),
- строгое подавление “хвостов” отложенных вызовов.

## 11) Расширение системы (следующие этапы, как встраиваются)

- Этап 2: Реестр NPC
  - регистрация/удаление NPC без обходов мира;
  - поддержка плотности и валидности.
- Этап 3+: Слоты и поведение
  - слот задаёт “пакет поведения” (точки, патрули, активности),
  - NPC реагирует только на события слота/RESYNC.
- Движение/блокировки
  - обработка “застрял/нет пути” через события/таймауты на стороне области или через “реактивные” триггеры (без NPC heartbeat);
  - очистка действий/перестроение маршрута по необходимости.

## 12) Критерии готовности архитектуры

Система считается корректной, если:

- при PC=0 в области NPC скрыты/остановлены через ScriptHidden;
- при первом PC область активируется, NPC получают RESYNC, тик стартует;
- пока слот не меняется — нет обхода NPC и нет рассылок;
- при смене слота — ровно одна рассылка EVT_SLOT_x всем NPC;
- при последнем выходе PC — тик прекращается через токен, NPC скрываются.
